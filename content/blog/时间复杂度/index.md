---

     title: 时间复杂度
     date: 2021-08-26T14:36:11.593Z
     description: 时间复杂度

---

## 循环不变量

### 定义

- 在每一次循环开始的时候, 都满足的性质

### 循环体

- 用于维持循环不变量

### demo

- 循环不变量: 在区间 [0, i - 1]中区间中都不存在 target 和 arr 的某一项相等(i 表示我们的结果)

- 循环体: if 语句 相等则得到结果 i 不相等则开始下一次循环，直到条件边界

```ts
function find<T>(arr: T[], target: T) {
  for (let i = 0; i < arr.length; i++) {
    // 循环体
    if (arr[i] === target) {
      return i;
    }
    return -1;
  }
}
```

## 复杂度分析

- 计算复杂性理论
- 表示算法的性能
- 通常是看代码运行最差的情况, 即算法运行的上界
- 复杂度描述的是随着数据规模 `n` 的增大, 算法性能的变化趋势

### 数据规模

- n: 算法作用在的数据的大小

### O(n): 随着数据规模 n 的增长 , 算法的复杂度成线性的关系

- 常数不重要

```shell
T1 = n
T1 = 100000n
T1 = 100000n  + 10000
```

### O(n^2)

- 比如: 嵌套循环, 遍历一个 n\* n 的二维数组

```shell
T2 = 2n^2
```

- 遍历一个 a \* a 的二维数组

```she
a * a = n
T = O(n)
```

### 常见的算法复杂度

- 明确 n 是谁

### O(logn): 对数复杂度

- 无论 log 的底数是多少, 都是通称算法为 O(logn)级别的算法(^表示对数)

```js
log2n = log10 ^ (n / log10) ^ 2;
```

- 数字 n 的二进制位数

1.  logn: 表示已 2 为底数

```js
while (n) {
  n % 2;
  n /= 2;
}
```

### O(根号 n)

- 求数字 n 的所有约数

```js
for (let i; i * i <= n; i++) {
  if (i % 2 === 0) {
  }
}
```

### O(2 的 n 次方) : 指数级别算法复杂度

- 长度为 n 的二进制数字

### O(n 的阶层): 阶层级别的算法复杂度

- 长度为 n 的数组的所有排列

### O(1): 算法的执行次数与 数据规模无关

- 判断数字 是否是偶数

```js
return 2 % 2;
```

### O(nlogn)

## 时间复杂度排序

## 算法测试用例

## java 中的泛型

- 泛型不可以是基本的数据类型, 需要使用基本类型的包装类对象

```java
public static <E> int search (E[] data , E target){}
```

- 数字类型传入泛形变量的时候, 会自动转换为其对应的包装类对象
